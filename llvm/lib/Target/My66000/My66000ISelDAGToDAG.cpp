//===- My66000ISelDAGToDAG.cpp - My66000 dag to dag inst selector - C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the My66000 target.
//
//===----------------------------------------------------------------------===//

#include "My66000.h"
#include "My66000TargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/KnownBits.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "my66000-dag2dag"

/// My66000DAGToDAGISel - My66000 specific code to select My66000 machine
/// instructions for SelectionDAG operations.
namespace {

class My66000DAGToDAGISel : public SelectionDAGISel {
public:
  My66000DAGToDAGISel(My66000TargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel) {}

  void Select(SDNode *N) override;

  StringRef getPassName() const override {
    return "My66000 DAG->DAG Pattern Instruction Selection";
  }

  bool SelectADDRri(SDValue Addr, SDValue &Base, SDValue &Offset);
  bool SelectADDRrr(SDValue Addr, SDValue &Base, SDValue &Index,
		    SDValue &Shift, SDValue &Offset);

private:
  void getShift(SDValue Addr, SDValue &Index, SDValue &Shift);
  bool tryExtract(SDNode *N, bool isSigned);
  bool tryInsert(SDNode *N, EVT VT);
  bool trySEX(SDNode *N);
  bool tryADDSUBCARRY(SDNode *N, bool isSub);

// Include the pieces autogenerated from the target description.
#include "My66000GenDAGISel.inc"
};

} // end anonymous namespace

/// This pass converts a legalized DAG into a My66000-specific DAG, ready for
/// instruction scheduling.
FunctionPass *llvm::createMy66000ISelDag(My66000TargetMachine &TM,
                                     CodeGenOpt::Level OptLevel) {
  return new My66000DAGToDAGISel(TM, OptLevel);
}


static bool isIntImmediate(SDNode *N, uint64_t &Imm) {
  if (const ConstantSDNode *C = dyn_cast<const ConstantSDNode>(N)) {
    Imm = C->getZExtValue();
    return true;
  }
  return false;
}

// isOpcWithIntImmediate - This method tests to see if the node is a specific
// opcode and that it has a immediate integer right operand.
// If so Imm will receive the value.
static bool isOpcWithIntImmediate(const SDNode *N, unsigned Opc, uint64_t &Imm) {
  return N->getOpcode() == Opc
         && isIntImmediate(N->getOperand(1).getNode(), Imm);
}

bool My66000DAGToDAGISel::SelectADDRri(SDValue Addr,
				       SDValue &Base, SDValue &Offset) {
LLVM_DEBUG(dbgs() << "My66000DAGToDAGISel::SelectADDRri\n");
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(
        FIN->getIndex(), TLI->getPointerTy(CurDAG->getDataLayout()));
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i64);
//dbgs() << "\tmatch 1\n";
    return true;
  }
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetGlobalTLSAddress)
{
//dbgs() << "\tfail 2\n";
    return false;  // direct calls.
}
  if (Addr.getOpcode() == ISD::ADD) {
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      if (isInt<16>(CN->getSExtValue())) {
        if (FrameIndexSDNode *FIN =
                dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
          // Constant offset from frame ref.
          Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
        } else {
          Base = Addr.getOperand(0);
        }
        Offset = CurDAG->getTargetConstant(CN->getZExtValue(), SDLoc(Addr),
                                           MVT::i64);
//dbgs() << "\tmatch 3\n";
        return true;
      }
    }
  }
  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i64);
//dbgs() << "\tmatch 4\n";
  return true;		// FIXME
}

/* Get shift amount, return false if not shift.
 * If shift amount > 3 then keep shift node.
 */
void My66000DAGToDAGISel::getShift(SDValue Addr, SDValue &Index, SDValue &Shift) {
unsigned shf;

 if (Addr.getOpcode() == ISD::SHL) {
    if (ConstantSDNode *CN =
	dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      shf = CN->getZExtValue();
      if (shf <= 3) {
	Shift = CurDAG->getTargetConstant(shf, SDLoc(Addr), MVT::i64);
	Index = Addr.getOperand(0);
//dbgs() << "shift <= 3\n";
      } else {	// keep shift node
	Shift = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i64);
	Index = Addr;
//dbgs() << "shift > 3\n";
      }
      return;
    }
  }
//dbgs() << "shift none\n";
  Shift = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i64);
  Index = Addr;
}

bool My66000DAGToDAGISel::SelectADDRrr(SDValue Addr,
				       SDValue &Base, SDValue &Index,
				       SDValue &Shift, SDValue &Offset) {
LLVM_DEBUG(dbgs() << "My66000DAGToDAGISel::SelectADDRrr\n");
  if (Addr.getOpcode() == ISD::FrameIndex) {
//dbgs() << "\tfail 1\n";
    return false;
  }
  if (Addr.getOpcode() == My66000ISD::WRAPPER) {
    Base  = CurDAG->getRegister(My66000::R0, MVT::i64);
    Index = CurDAG->getRegister(My66000::R0, MVT::i64);
    Shift = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i64);
    Offset = Addr.getOperand(0);
//dbgs() << "\tmatch 1\n";
    return true;
  }
  if (Addr.getOpcode() == ISD::ADD) {
    if (Addr.getOperand(1).getOpcode() == My66000ISD::WRAPPER) {
      Base  = CurDAG->getRegister(My66000::R0, MVT::i64);
      getShift(Addr.getOperand(0), Index, Shift);
      Offset = Addr.getOperand(1).getOperand(0);
//dbgs() << "\tmatch 2\n";
      return true;
    } else {	// not TargetGlobalAddress
      if (Addr.getOperand(0).getOpcode() == ISD::ADD) { // add of add
	Base = Addr.getOperand(0).getOperand(0);
	getShift(Addr.getOperand(0).getOperand(1), Index, Shift);
	if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
          Offset = CurDAG->getTargetConstant(CN->getZExtValue(), SDLoc(Addr),
					     MVT::i64);
//dbgs() << "\tmatch 3\n";
          return true;
	}
      }	else {	// not add of add, just add
	Base = Addr.getOperand(0);
        if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
	  // base + displacement
          if (isInt<16>(CN->getSExtValue())) {
//dbgs() << "\tdefer to ri\n";
	    return false; // simple base + 16-bit displacement, handle elsewhere
          }
	  // base + large displacement
	  Index = CurDAG->getRegister(My66000::R0, MVT::i64);
	  Shift = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i64);;
	  Offset = CurDAG->getTargetConstant(CN->getZExtValue(), SDLoc(Addr),
                                             MVT::i64);
//dbgs() << "\tmatch 4\n";
          return true;
        } else { // not a constant node
	  getShift(Addr.getOperand(1), Index, Shift);
	  Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i64);
//dbgs() << "\tmatch 5\n";
          return true;
	}
      }
    }
  }
//dbgs() << "fail 3\n";
  return false;
}

// Found an AND, could be an extract or a bit clear
bool My66000DAGToDAGISel::tryExtract(SDNode *N, bool isSigned) {
LLVM_DEBUG(dbgs() << "My66000DAGToDAGISel::tryExtract " << N->getOperationName(0) << "\n");
  SDLoc dl(N);

  // look for idiom AND of a SRL => unsigned extract
  uint64_t Andimm = 0;
  uint64_t Shfimm = 0;
  if (N->getOpcode() == ISD::AND) {
    if (isOpcWithIntImmediate(N, ISD::AND, Andimm)) {
      // The immediate is a mask of the low bits iff imm & (imm+1) == 0
      if (Andimm & (Andimm + 1))
        return false;
      if (isOpcWithIntImmediate(N->getOperand(0).getNode(), ISD::SRL, Shfimm)) {
        assert(Shfimm > 0 && Shfimm < 64 && "bad amount in shift node!");
        // Mask off the unnecessary bits of the AND immediate; normally
        // DAGCombine will do this, but that might not happen if
        // targetShrinkDemandedConstant chooses a different immediate.
        Andimm &= -1U >> Shfimm;
        unsigned Width = countTrailingOnes(Andimm);
        unsigned Offset = Shfimm;
LLVM_DEBUG(dbgs() << "\tunsigned extract pattern #1: w=" << Width << " o=" << Offset << "\n");
        SDValue Ops[] = { N->getOperand(0).getOperand(0),
                          CurDAG->getTargetConstant(Width, dl, MVT::i64),
                          CurDAG->getTargetConstant(Offset, dl, MVT::i64) };
        CurDAG->SelectNodeTo(N, My66000::SRLri, MVT::i64, Ops);
        return true;
      }
      else
      {	// We have AND with a mask.
        unsigned Width = countTrailingOnes(Andimm);
	if (Width > 15)
	{ // A large mask is better done by SRLri than AND imm
LLVM_DEBUG(dbgs() << "\tunsigned extract pattern #2: w=" << Width <<  "\n");
          SDValue Ops[] = { N->getOperand(0),
                            CurDAG->getTargetConstant(Width, dl, MVT::i64),
                            CurDAG->getTargetConstant(0, dl, MVT::i64) };
	  CurDAG->SelectNodeTo(N, My66000::SRLri, MVT::i64, Ops);
          return true;
	}
      }
    } else {	// AND of non-immediate
      // Look for bit clear idiom with and(r,(rotl -2,r))
      SDNode *N1 = N->getOperand(1).getNode();
      if (N1->getOpcode() == ISD::ROTL &&
	  isIntImmediate(N1->getOperand(0).getNode(), Shfimm) &&
	  Shfimm == uint64_t(-2)) {
LLVM_DEBUG(dbgs() << "\tbit clear idiom\n");
	SDNode *NShf = CurDAG->getMachineNode(My66000::SLLwr, dl, MVT::i64,
			    CurDAG->getTargetConstant(1, dl, MVT::i64),
			    N1->getOperand(1));
	CurDAG->SelectNodeTo(N, My66000::ANDrn, MVT::i64,
			    N->getOperand(0),
			    SDValue(NShf, 0));
        return true;
      }
    }
  } else if (isOpcWithIntImmediate(N, ISD::SRA, Shfimm)) {
    uint64_t Shf2imm;
//dbgs() << "\tSRA extract\n";
    if (isOpcWithIntImmediate(N->getOperand(0).getNode(), ISD::SHL, Shf2imm)) {
      SDValue Ops[] = { N->getOperand(0).getOperand(0),
                        CurDAG->getTargetConstant(Shf2imm, dl, MVT::i64),
                        CurDAG->getTargetConstant(Shfimm, dl, MVT::i64) };
      CurDAG->SelectNodeTo(N, My66000::SRAri, MVT::i64, Ops);
LLVM_DEBUG(dbgs() << "\tsigned extract pattern #3: w=" << Shf2imm <<  " o=" << Shfimm << "\n");
      return true;
    }
  } else if (N->getOpcode() == ISD::SRL) {
LLVM_DEBUG(dbgs() << "\tSRL extract not implemented\n");
}
  return false;
}

/* Looking for (OR(AND(reg1,imm),SHL(reg2,imm)))
 * The AND imm should be 1...10...01...1 where there could be no low order 1s.
 * If there are low order 1's, the count should be the shift amount.
 */
bool My66000DAGToDAGISel::tryInsert(SDNode *N, EVT VT) {
LLVM_DEBUG(dbgs() << "My66000DAGToDAGISel::tryInsert " << N->getOperationName(0) << "\n");
  SDLoc dl(N);
  uint64_t Andimm = 0;
  uint64_t Shfimm = 0;

  // FIXME - do we have to check that AND is single use?
  if (isOpcWithIntImmediate(N->getOperand(0).getNode(), ISD::AND, Andimm)) {
      isOpcWithIntImmediate(N->getOperand(1).getNode(), ISD::SHL, Shfimm);
    // Extend mask to 64-bits
    if (VT == MVT::i32) Andimm |= 0xFFFFFFFF00000000;
    if (VT == MVT::i16) Andimm |= 0xFFFFFFFFFFFF0000;
    if (VT == MVT::i8)  Andimm |= 0xFFFFFFFFFFFFFF00;
//dbgs() << "\tmask1="; PrintHex(Andimm); dbgs() << "\n";
//dbgs() << "\tmask2="; PrintHex(Andimm >> Shfimm); dbgs() << "\n";
    unsigned Width = countTrailingZeros(Andimm >> Shfimm);
    if (Width == 0 || !isShiftedMask_64(~Andimm)) {
//dbgs() << "\tfail, not a mask\n";
      return false;
    }
    unsigned Offset = Shfimm;
//dbgs() << "\tinsert pattern #1: w=" << Width << " o=" << Offset << "\n";
    SDValue Ops[] = { N->getOperand(0).getOperand(0),
		      N->getOperand(1).getOperand(0),
		      CurDAG->getTargetConstant(Width, dl, MVT::i32),
		      CurDAG->getTargetConstant(Offset, dl, MVT::i32) };
    SDNode *INS = CurDAG->getMachineNode(My66000::INSrrw, dl, MVT::i64, Ops);
    ReplaceNode(N, INS);
    return true;
  }
  return false;
}

bool My66000DAGToDAGISel::trySEX(SDNode *N) {
  SDLoc dl(N);
  unsigned Width = cast<VTSDNode>(N->getOperand(1))->getVT().getSizeInBits();
//dbgs() << "\tsign extend pattern: w=" << Width << "\n";
  SDValue Ops[] = { N->getOperand(0),
		    CurDAG->getTargetConstant(Width, dl, MVT::i64),
		    CurDAG->getTargetConstant(0, dl, MVT::i64) };
  CurDAG->SelectNodeTo(N, My66000::SRAri, MVT::i64, Ops);
  return true;
}

void My66000DAGToDAGISel::Select(SDNode *N) {
LLVM_DEBUG(dbgs() << "My66000DAGToDAGISel::Select " << N->getOperationName(CurDAG) << "\n");
  SDLoc dl(N);

  if (N->isMachineOpcode()) {
    N->setNodeId(-1);
    return;   // Already selected.
  }

  switch (N->getOpcode()) {
  case ISD::FrameIndex: {
    EVT VT = N->getValueType(0);
    SDValue Imm = CurDAG->getTargetConstant(0, dl, MVT::i64);
    int FI = cast<FrameIndexSDNode>(N)->getIndex();
    SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
    ReplaceNode(N, CurDAG->getMachineNode(My66000::ADDri, dl, VT, TFI, Imm));
    return;
  }
  case ISD::AND:
    if (tryExtract(N, false))	// check for unsigned bitfield extract
      return;
    break;
  case ISD::SRL:
    if (tryExtract(N, false))	// check for unsigned bitfield extract
      return;
    break;
  case ISD::SRA:
    if (tryExtract(N, true))	// check for signed bitfield extract
      return;
    break;
  case ISD::SIGN_EXTEND_INREG:
    if (trySEX(N))
      return;
    break;
  case ISD::STORE: {
    const StoreSDNode *ST = dyn_cast<StoreSDNode>(N);
    EVT VT = ST->getMemoryVT();
    // Operand(0) is the chain
    if (N->getOperand(1).getOpcode() == ISD::OR)
      tryInsert(N->getOperand(1).getNode(), VT); // check for bitfield insert
    // no return because we didn't replace the STORE
    break;
  }
  }
  SelectCode(N);
}
